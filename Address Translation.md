<b>1. Hardware-based address translation/Address translation</b>
- the hardware transforms each memory access (e.g, an instruction fetch, load, store), by changing the <b>virtual address</b> provided by the instruction to a <b>physical address</b> where the desired information is actually located.

- Thus, on each and every memory reference, an address translation is performed by the hardware to redirect application memory references to their actual locations in memory.

- The OS must get involved at key points to set up the hardware so that the correct translations take place; it must thus manage memory, keeping track of which
locations are free and which are in use, and judiciously intervening to
maintain control over how memory is used.

- Once again the goal of all of this work is to create a beautiful illusion:
that the program has its own private memory, where its own code and data reside. Behind that virtual reality lies the ugly physical truth:
that many programs are actually sharing memory at the same time, as
the CPU (or CPUs) switches between running one program and the next.

<b>2. Base & Bounds/Dynamic relocation</b>
We’ll need two hardware registers within each CPU: 
- one is called the base register, 
- the other is called the bounds (sometimes called a
limit register). 
- This base-and-bounds pair allows us to place the address space anywhere we’d like in physical memory.
- In this setup, each program is written and compiled as if it is loaded at
address zero. However, when a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value. 
- For example, the OS decides to load the process at
physical address 32 KB and thus sets the base register to this value.
- what happens once the process starts running? any memory reference that is generated by the process, it is translated by the processor in the following manner:
<i>physical address = virtual address + base</i>
- Each memory reference generated by the process is a virtual address;
the hardware in turn adds the contents of the base register to this address
and the result is a physical address
- Transforming a virtual address into a physical address is exactly the
technique we refer to as address translation; that is, the hardware takes a
virtual address the process thinks it is referencing and transforms it into
a physical address which is where the data actually resides. 

<u><b>Functions of the bounds register:</b></u>
- A bounds (or limit) register ensures that such addresses are within the confines of the address space.
- the bounds register is there to help with protection.
- the processor will first check that the memory reference is within bounds to make sure it is legal. 
- The point of the bounds is thus to make sure that all addresses generated by the process are legal and within the “bounds” of the process.

<u><b>MMU: Memory Management Unit</b></u> is the part of the processor that helps with address translation.

<u><b>Problems with Dynamic Relocation:</b></u>
1. Can result in <b>internal fragmentation</b>, which is the wasted space between the stack and the heap, since neither are too big. Thus, we need a better way to avoid internal fragmentation and utilize physical memory.
