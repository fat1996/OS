1. Hradware-based address translation/Address translation
- the hardware transforms each memory access (e.g, an instruction fetch, load, store), changing the <b>virtual address</b> provided by the instruction to a <b>physical address</b> where the desired information is actually located.
- Thus, on each and every memory
reference, an address translation is performed by the hardware to redirect
application memory references to their actual locations in memory.
- The OS must get
involved at key points to set up the hardware so that the correct translations
take place; it must thus manage memory, keeping track of which
locations are free and which are in use, and judiciously intervening to
maintain control over how memory is used.
- Once again the goal of all of this work is to create a beautiful illusion:
that the program has its own private memory, where its own code
and data reside. Behind that virtual reality lies the ugly physical truth:
that many programs are actually sharing memory at the same time, as
the CPU (or CPUs) switches between running one program and the next.

<b>Base & Bounds/Dynamic reloaction</b>
Specifically, we’ll need two hardware registers within each CPU: one
is called the base register, and the other the bounds (sometimes called a
limitregister). This base-and-bounds pair is going to allow us to place the
address space anywhere we’d like in physical memory.
In this setup, each program is written and compiled as if it is loaded at
address zero. However, when a program starts running, the OS decides
where in physical memory it should be loaded and sets the base register
to that value. 
For example, the OS decides to load the process at
physical address 32 KB and thus sets the base register to this value.

Interesting things start to happen when the process is running. Now,
when any memory reference is generated by the process, it is translated
by the processor in the following manner:
physical address = virtual address + base

Each memory reference generated by the process is a virtual address;
the hardware in turn adds the contents of the base register to this address
and the result is a physical address

Transforming a virtual address into a physical address is exactly the
technique we refer to as address translation; that is, the hardware takes a
virtual address the process thinks it is referencing and transforms it into
a physical address which is where the data actually resides. Because this
relocation of the address happens at runtime, and because we can move
address spaces even after the process has started running, the technique
is often referred to as dynamic relocation

A bounds (or limit) register ensures that
such addresses are within the confines of the address space.As
you might have guessed, the bounds register is there to help with protection.
Specifically, the processor will first check that the memory reference
is within bounds to make sure it is legal. The point of the bounds is thus to make sure that all addresses generated
by the process are legal and within the “bounds” of the process.

 Sometimes people call the
part of the processor that helps with address translation the memory
management unit (MMU).

<b>Problems with dynamic relocation:</b>
1. Can result in <b>internal fragmentation</b>, which is the wasted space between the stack and the heap, since neither are too big. Thus, we need a better way to avoid internal fragmentation and utilize physical memory.
